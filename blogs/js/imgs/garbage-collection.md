---
title: JavaScript 中的垃圾回收
date: 2022-02-28
tags:
 - js
categories:
 - js
---

- 垃圾回收是一种自动的内存管理机制。当计算机上的动态内存不再需要时，就应该予以释放，以让出内存。

## 垃圾回收方法

### 引用计数（reference counting）

- 在内存管理环境中，对象 A 如果有访问对象 B 的权限，叫做对象 A 引用对象 B。引用计数的策略是将“对象是否不再需要”简化成“对象有没有其他对象引用到它”，如果没有对象引用这个对象，那么这个对象将会被回收。

```js
let obj1 = { a: 1 }; // 一个对象（称之为 A）被创建，赋值给 obj1，A 的引用个数为 1
let obj2 = obj1; // A 的引用个数变为 2

obj1 = 0; // A 的引用个数变为 1
obj2 = 0; // A 的引用个数变为 0，此时对象 A 就可以被垃圾回收了
```

- 引用计数最大的问题： 循环引用。

```js
function func() {
    let obj1 = {};
    let obj2 = {};
    obj1.a = obj2; // obj1 引用 obj2
    obj2.a = obj1; // obj2 引用 obj1
}
```

- 当函数 func 执行结束后，返回值为 undefined，所以整个函数以及内部的变量都应该被回收，但根据引用计数方法，obj1 和 obj2 的引用次数都不为 0，所以他们不会被回收。
- 要解决循环引用的问题，最好是在不使用它们的时候手工将它们设为空

```js
obj1 = null;
obj2 = null;
```

### 标记-清除（mark and sweep）

- JavaScript 中有个全局对象，浏览器中是 window。定期的，垃圾回收期将从这个全局对象开始，找所有从这个全局对象开始引用的对象，再找这些对象引用的对象...对这些活着的对象进行标记，这是标记阶段。清除阶段就是清除那些没有被标记的对象。
- 标记－清除法的一个问题就是不那么有效率，因为在标记－清除阶段，整个程序将会等待，所以如果程序出现卡顿的情况，那有可能是收集垃圾的过程。
- 标记清除有一个问题，就是在清除之后，内存空间是不连续的，即出现了内存碎片。如果后面需要一个比较大的连续的内存空间时，那将不能满足要求。而标记-整理方法可以有效地解决这个问题。标记阶段没有什么不同，只是标记结束后，标记-整理方法会将活着的对象向内存的一边移动，最后清理掉边界的内存。

## 内存泄漏

### 循环引用

一旦数据不再使用，最好通过将其值设为 null 来释放其引用，这个方法被称为“解除引用”。

### 无意的全局变量

```js
function foo(arg) {
    bar = ""; // this.bar = "";
}
foo();
```

- 上面的代码就无意中声明了一个全局变量，会得到 window 的引用，bar 实际上是 window.bar，它的作用域在 window 上，所以 foo 函数执行结束后，bar 也不会被内存收回。

### 被遗忘的计时器和回调函数

当不需要 interval 或者 timeout 时，最好调用 clearInterval 或者 clearTimeout。

```js
let someResource = getData();
setInterval(() => {
    const node = document.getElementById('Node');
    if(node) {
        node.innerHTML = JSON.stringify(someResource));
    }
}, 1000);
```

## 良好实践

- 只保留程序运行时需要的数据，对于已经使用的或者不需要的数据，应该将其值设为 null
- 避免创建对象,使用 array.length = 0 来清空数组
