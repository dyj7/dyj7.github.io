---
title: JavaScript 中的 Event Loop（事件循环）机制
date: 2022-03-01
tags:
 - js
categories:
 - js
---

## 为什么JavaScript是单线程？

- JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。
- 作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。
- 假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点,会带来很复杂的同步问题。

## JavaScript 事件循环（Event Loop）

JS 任务分为两类:

- 同步任务：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务
- 异步任务：不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行

<img src='./imgs/js-1.png' />

- 同步和异步任务分别进入不同的执行"场所"，同步的进入主线程，异步的进入Event Table并注册函数。
- 当指定的事情完成时，Event Table会将这个函数移入Event Queue。
- 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。
- 上述过程会不断重复，也就是常说的Event Loop(事件循环)。

js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。

- js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码…，如此反复，这样就形成了一个无限的循环。

## 事件和回调函数

"任务队列"是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在"任务队列"中添加一个事件，表示相关的异步任务可以进入"执行栈"了。主线程读取"任务队列"，就是读取里面有哪些事件。

"任务队列"中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入"任务队列"，等待主线程读取。

所谓"回调函数"（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。

"任务队列"是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，"任务队列"上第一位的事件就自动进入主线程。但是，由于存在后文提到的"定时器"功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。

## 微任务和宏任务

- 微任务:常见的定时器,用户交互事件等(script(整体代码)本身就是一个宏任务)
<img src='./imgs/js-2.png' />

- 微任务:Promise相关任务,MutationObserver等
<img src='./imgs/js-3.png' />

- 宏任务必然是在微任务之后才执行的（因为微任务实际上是宏任务的其中一个步骤）
    - 执行一个宏任务（栈中没有就从事件队列中获取）
    - 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
    - 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
    - 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染
    - 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）
    <img src='./imgs/js-4.png' />

```js
function app() {
    setTimeout(() => {
    console.log("1-1");
    Promise.resolve().then(() => {
        console.log("2-1");
    });
    });
    console.log("1-2");
    Promise.resolve().then(() => {
    console.log("1-3");
    setTimeout(() => {
        console.log("3-1");
    });
    });
}
app();
// 1-2
// 1-3
// 1-1
// 2-1
// 3-1
```

## 参考

- [今天，我明白了JS事件循环机制](https://zhuanlan.zhihu.com/p/75572565)
- [js中的宏任务与微任务](https://zhuanlan.zhihu.com/p/78113300)
- [微任务、宏任务与Event-Loop](https://juejin.cn/post/6844903657264136200)
- [JavaScript 运行机制详解：再谈Event Loop](https://www.ruanyifeng.com/blog/2014/10/event-loop.html)
